// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: user_user_m2m.sql

package db

import (
	"context"
)

const createUserToUser = `-- name: CreateUserToUser :one
INSERT INTO "UserToUser" (
	"FirstUserUuid",
    "SecondUserUuid") 
VALUES (
    $1,
    $2
)
RETURNING "FirstUserUuid", "SecondUserUuid"
`

type CreateUserToUserParams struct {
	FirstUserUuid  int64 `json:"FirstUserUuid"`
	SecondUserUuid int64 `json:"SecondUserUuid"`
}

func (q *Queries) CreateUserToUser(ctx context.Context, arg CreateUserToUserParams) (UserToUser, error) {
	row := q.db.QueryRowContext(ctx, createUserToUser, arg.FirstUserUuid, arg.SecondUserUuid)
	var i UserToUser
	err := row.Scan(&i.FirstUserUuid, &i.SecondUserUuid)
	return i, err
}

const deleteUserToUser = `-- name: DeleteUserToUser :exec
DELETE FROM "UserToUser"
WHERE "FirstUserUuid" = $1 
    AND "SecondUserUuid" = $2
`

type DeleteUserToUserParams struct {
	FirstUserUuid  int64 `json:"FirstUserUuid"`
	SecondUserUuid int64 `json:"SecondUserUuid"`
}

func (q *Queries) DeleteUserToUser(ctx context.Context, arg DeleteUserToUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserToUser, arg.FirstUserUuid, arg.SecondUserUuid)
	return err
}

const getUserToUser = `-- name: GetUserToUser :one
SELECT "FirstUserUuid", "SecondUserUuid" FROM "UserToUser"
WHERE "FirstUserUuid" = $1 
    AND "SecondUserUuid" = $2 
LIMIT 1
`

type GetUserToUserParams struct {
	FirstUserUuid  int64 `json:"FirstUserUuid"`
	SecondUserUuid int64 `json:"SecondUserUuid"`
}

func (q *Queries) GetUserToUser(ctx context.Context, arg GetUserToUserParams) (UserToUser, error) {
	row := q.db.QueryRowContext(ctx, getUserToUser, arg.FirstUserUuid, arg.SecondUserUuid)
	var i UserToUser
	err := row.Scan(&i.FirstUserUuid, &i.SecondUserUuid)
	return i, err
}

const listUserToUser = `-- name: ListUserToUser :many
SELECT "FirstUserUuid", "SecondUserUuid" FROM "UserToUser"
ORDER BY "FirstUserUuid"
LIMIT $1
OFFSET $2
`

type ListUserToUserParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserToUser(ctx context.Context, arg ListUserToUserParams) ([]UserToUser, error) {
	rows, err := q.db.QueryContext(ctx, listUserToUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserToUser
	for rows.Next() {
		var i UserToUser
		if err := rows.Scan(&i.FirstUserUuid, &i.SecondUserUuid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserToUser = `-- name: UpdateUserToUser :one
UPDATE "UserToUser"
  set "FirstUserUuid" = $3,
      "SecondUserUuid" = $4
WHERE "FirstUserUuid" = $1 
    AND "SecondUserUuid" = $2
RETURNING "FirstUserUuid", "SecondUserUuid"
`

type UpdateUserToUserParams struct {
	FirstUserUuid    int64 `json:"FirstUserUuid"`
	SecondUserUuid   int64 `json:"SecondUserUuid"`
	FirstUserUuid_2  int64 `json:"FirstUserUuid_2"`
	SecondUserUuid_2 int64 `json:"SecondUserUuid_2"`
}

func (q *Queries) UpdateUserToUser(ctx context.Context, arg UpdateUserToUserParams) (UserToUser, error) {
	row := q.db.QueryRowContext(ctx, updateUserToUser,
		arg.FirstUserUuid,
		arg.SecondUserUuid,
		arg.FirstUserUuid_2,
		arg.SecondUserUuid_2,
	)
	var i UserToUser
	err := row.Scan(&i.FirstUserUuid, &i.SecondUserUuid)
	return i, err
}
